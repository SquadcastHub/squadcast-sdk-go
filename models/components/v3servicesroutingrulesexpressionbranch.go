// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/SquadcastHub/squadcast-sdk-go/internal/utils"
)

type V3ServicesRoutingRulesExpressionBranchOp string

const (
	V3ServicesRoutingRulesExpressionBranchOpIs          V3ServicesRoutingRulesExpressionBranchOp = "is"
	V3ServicesRoutingRulesExpressionBranchOpIsNot       V3ServicesRoutingRulesExpressionBranchOp = "is_not"
	V3ServicesRoutingRulesExpressionBranchOpMatches     V3ServicesRoutingRulesExpressionBranchOp = "matches"
	V3ServicesRoutingRulesExpressionBranchOpNotContains V3ServicesRoutingRulesExpressionBranchOp = "not_contains"
	V3ServicesRoutingRulesExpressionBranchOpGt          V3ServicesRoutingRulesExpressionBranchOp = "gt"
	V3ServicesRoutingRulesExpressionBranchOpLt          V3ServicesRoutingRulesExpressionBranchOp = "lt"
	V3ServicesRoutingRulesExpressionBranchOpGtEq        V3ServicesRoutingRulesExpressionBranchOp = "gt_eq"
	V3ServicesRoutingRulesExpressionBranchOpLtEq        V3ServicesRoutingRulesExpressionBranchOp = "lt_eq"
	V3ServicesRoutingRulesExpressionBranchOpCall        V3ServicesRoutingRulesExpressionBranchOp = "call"
	V3ServicesRoutingRulesExpressionBranchOpFieldIs     V3ServicesRoutingRulesExpressionBranchOp = "field_is"
	V3ServicesRoutingRulesExpressionBranchOpFieldIsNot  V3ServicesRoutingRulesExpressionBranchOp = "field_is_not"
	V3ServicesRoutingRulesExpressionBranchOpFieldGt     V3ServicesRoutingRulesExpressionBranchOp = "field_gt"
	V3ServicesRoutingRulesExpressionBranchOpFieldLt     V3ServicesRoutingRulesExpressionBranchOp = "field_lt"
	V3ServicesRoutingRulesExpressionBranchOpFieldGtEq   V3ServicesRoutingRulesExpressionBranchOp = "field_gt_eq"
	V3ServicesRoutingRulesExpressionBranchOpFieldLtEq   V3ServicesRoutingRulesExpressionBranchOp = "field_lt_eq"
)

func (e V3ServicesRoutingRulesExpressionBranchOp) ToPointer() *V3ServicesRoutingRulesExpressionBranchOp {
	return &e
}
func (e *V3ServicesRoutingRulesExpressionBranchOp) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "is":
		fallthrough
	case "is_not":
		fallthrough
	case "matches":
		fallthrough
	case "not_contains":
		fallthrough
	case "gt":
		fallthrough
	case "lt":
		fallthrough
	case "gt_eq":
		fallthrough
	case "lt_eq":
		fallthrough
	case "call":
		fallthrough
	case "field_is":
		fallthrough
	case "field_is_not":
		fallthrough
	case "field_gt":
		fallthrough
	case "field_lt":
		fallthrough
	case "field_gt_eq":
		fallthrough
	case "field_lt_eq":
		*e = V3ServicesRoutingRulesExpressionBranchOp(v)
		return nil
	default:
		return fmt.Errorf("invalid value for V3ServicesRoutingRulesExpressionBranchOp: %v", v)
	}
}

type V3ServicesRoutingRulesExpressionBranchRHSType string

const (
	V3ServicesRoutingRulesExpressionBranchRHSTypeStr     V3ServicesRoutingRulesExpressionBranchRHSType = "str"
	V3ServicesRoutingRulesExpressionBranchRHSTypeBoolean V3ServicesRoutingRulesExpressionBranchRHSType = "boolean"
	V3ServicesRoutingRulesExpressionBranchRHSTypeInt32   V3ServicesRoutingRulesExpressionBranchRHSType = "int32"
	V3ServicesRoutingRulesExpressionBranchRHSTypeFloat32 V3ServicesRoutingRulesExpressionBranchRHSType = "float32"
)

type V3ServicesRoutingRulesExpressionBranchRHS struct {
	Str     *string  `queryParam:"inline,name=rhs"`
	Boolean *bool    `queryParam:"inline,name=rhs"`
	Int32   *int     `queryParam:"inline,name=rhs"`
	Float32 *float32 `queryParam:"inline,name=rhs"`

	Type V3ServicesRoutingRulesExpressionBranchRHSType
}

func CreateV3ServicesRoutingRulesExpressionBranchRHSStr(str string) V3ServicesRoutingRulesExpressionBranchRHS {
	typ := V3ServicesRoutingRulesExpressionBranchRHSTypeStr

	return V3ServicesRoutingRulesExpressionBranchRHS{
		Str:  &str,
		Type: typ,
	}
}

func CreateV3ServicesRoutingRulesExpressionBranchRHSBoolean(boolean bool) V3ServicesRoutingRulesExpressionBranchRHS {
	typ := V3ServicesRoutingRulesExpressionBranchRHSTypeBoolean

	return V3ServicesRoutingRulesExpressionBranchRHS{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateV3ServicesRoutingRulesExpressionBranchRHSInt32(int32T int) V3ServicesRoutingRulesExpressionBranchRHS {
	typ := V3ServicesRoutingRulesExpressionBranchRHSTypeInt32

	return V3ServicesRoutingRulesExpressionBranchRHS{
		Int32: &int32T,
		Type:  typ,
	}
}

func CreateV3ServicesRoutingRulesExpressionBranchRHSFloat32(float32T float32) V3ServicesRoutingRulesExpressionBranchRHS {
	typ := V3ServicesRoutingRulesExpressionBranchRHSTypeFloat32

	return V3ServicesRoutingRulesExpressionBranchRHS{
		Float32: &float32T,
		Type:    typ,
	}
}

func (u *V3ServicesRoutingRulesExpressionBranchRHS) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = V3ServicesRoutingRulesExpressionBranchRHSTypeStr
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = V3ServicesRoutingRulesExpressionBranchRHSTypeBoolean
		return nil
	}

	var int32Var int = 0
	if err := utils.UnmarshalJSON(data, &int32Var, "", true, nil); err == nil {
		u.Int32 = &int32Var
		u.Type = V3ServicesRoutingRulesExpressionBranchRHSTypeInt32
		return nil
	}

	var float32Var float32 = float32(0)
	if err := utils.UnmarshalJSON(data, &float32Var, "", true, nil); err == nil {
		u.Float32 = &float32Var
		u.Type = V3ServicesRoutingRulesExpressionBranchRHSTypeFloat32
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for V3ServicesRoutingRulesExpressionBranchRHS", string(data))
}

func (u V3ServicesRoutingRulesExpressionBranchRHS) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Int32 != nil {
		return utils.MarshalJSON(u.Int32, "", true)
	}

	if u.Float32 != nil {
		return utils.MarshalJSON(u.Float32, "", true)
	}

	return nil, errors.New("could not marshal union type V3ServicesRoutingRulesExpressionBranchRHS: all fields are null")
}

type V3ServicesRoutingRulesExpressionBranch struct {
	LHS string                                    `json:"lhs"`
	Op  *V3ServicesRoutingRulesExpressionBranchOp `json:"op,omitempty"`
	RHS V3ServicesRoutingRulesExpressionBranchRHS `json:"rhs"`
}

func (v *V3ServicesRoutingRulesExpressionBranch) GetLHS() string {
	if v == nil {
		return ""
	}
	return v.LHS
}

func (v *V3ServicesRoutingRulesExpressionBranch) GetOp() *V3ServicesRoutingRulesExpressionBranchOp {
	if v == nil {
		return nil
	}
	return v.Op
}

func (v *V3ServicesRoutingRulesExpressionBranch) GetRHS() V3ServicesRoutingRulesExpressionBranchRHS {
	if v == nil {
		return V3ServicesRoutingRulesExpressionBranchRHS{}
	}
	return v.RHS
}
