// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/SquadcastHub/squadcast-sdk-go/squadcastv1/internal/utils"
)

type V3ServicesDeduplicationRulesExpressionBranchOp string

const (
	V3ServicesDeduplicationRulesExpressionBranchOpIs          V3ServicesDeduplicationRulesExpressionBranchOp = "is"
	V3ServicesDeduplicationRulesExpressionBranchOpIsNot       V3ServicesDeduplicationRulesExpressionBranchOp = "is_not"
	V3ServicesDeduplicationRulesExpressionBranchOpMatches     V3ServicesDeduplicationRulesExpressionBranchOp = "matches"
	V3ServicesDeduplicationRulesExpressionBranchOpNotContains V3ServicesDeduplicationRulesExpressionBranchOp = "not_contains"
	V3ServicesDeduplicationRulesExpressionBranchOpGt          V3ServicesDeduplicationRulesExpressionBranchOp = "gt"
	V3ServicesDeduplicationRulesExpressionBranchOpLt          V3ServicesDeduplicationRulesExpressionBranchOp = "lt"
	V3ServicesDeduplicationRulesExpressionBranchOpGtEq        V3ServicesDeduplicationRulesExpressionBranchOp = "gt_eq"
	V3ServicesDeduplicationRulesExpressionBranchOpLtEq        V3ServicesDeduplicationRulesExpressionBranchOp = "lt_eq"
	V3ServicesDeduplicationRulesExpressionBranchOpCall        V3ServicesDeduplicationRulesExpressionBranchOp = "call"
	V3ServicesDeduplicationRulesExpressionBranchOpFieldIs     V3ServicesDeduplicationRulesExpressionBranchOp = "field_is"
	V3ServicesDeduplicationRulesExpressionBranchOpFieldIsNot  V3ServicesDeduplicationRulesExpressionBranchOp = "field_is_not"
	V3ServicesDeduplicationRulesExpressionBranchOpFieldGt     V3ServicesDeduplicationRulesExpressionBranchOp = "field_gt"
	V3ServicesDeduplicationRulesExpressionBranchOpFieldLt     V3ServicesDeduplicationRulesExpressionBranchOp = "field_lt"
	V3ServicesDeduplicationRulesExpressionBranchOpFieldGtEq   V3ServicesDeduplicationRulesExpressionBranchOp = "field_gt_eq"
	V3ServicesDeduplicationRulesExpressionBranchOpFieldLtEq   V3ServicesDeduplicationRulesExpressionBranchOp = "field_lt_eq"
)

func (e V3ServicesDeduplicationRulesExpressionBranchOp) ToPointer() *V3ServicesDeduplicationRulesExpressionBranchOp {
	return &e
}
func (e *V3ServicesDeduplicationRulesExpressionBranchOp) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "is":
		fallthrough
	case "is_not":
		fallthrough
	case "matches":
		fallthrough
	case "not_contains":
		fallthrough
	case "gt":
		fallthrough
	case "lt":
		fallthrough
	case "gt_eq":
		fallthrough
	case "lt_eq":
		fallthrough
	case "call":
		fallthrough
	case "field_is":
		fallthrough
	case "field_is_not":
		fallthrough
	case "field_gt":
		fallthrough
	case "field_lt":
		fallthrough
	case "field_gt_eq":
		fallthrough
	case "field_lt_eq":
		*e = V3ServicesDeduplicationRulesExpressionBranchOp(v)
		return nil
	default:
		return fmt.Errorf("invalid value for V3ServicesDeduplicationRulesExpressionBranchOp: %v", v)
	}
}

type V3ServicesDeduplicationRulesExpressionBranchRHSType string

const (
	V3ServicesDeduplicationRulesExpressionBranchRHSTypeStr     V3ServicesDeduplicationRulesExpressionBranchRHSType = "str"
	V3ServicesDeduplicationRulesExpressionBranchRHSTypeBoolean V3ServicesDeduplicationRulesExpressionBranchRHSType = "boolean"
	V3ServicesDeduplicationRulesExpressionBranchRHSTypeInt32   V3ServicesDeduplicationRulesExpressionBranchRHSType = "int32"
	V3ServicesDeduplicationRulesExpressionBranchRHSTypeFloat32 V3ServicesDeduplicationRulesExpressionBranchRHSType = "float32"
)

type V3ServicesDeduplicationRulesExpressionBranchRHS struct {
	Str     *string  `queryParam:"inline,name=rhs"`
	Boolean *bool    `queryParam:"inline,name=rhs"`
	Int32   *int     `queryParam:"inline,name=rhs"`
	Float32 *float32 `queryParam:"inline,name=rhs"`

	Type V3ServicesDeduplicationRulesExpressionBranchRHSType
}

func CreateV3ServicesDeduplicationRulesExpressionBranchRHSStr(str string) V3ServicesDeduplicationRulesExpressionBranchRHS {
	typ := V3ServicesDeduplicationRulesExpressionBranchRHSTypeStr

	return V3ServicesDeduplicationRulesExpressionBranchRHS{
		Str:  &str,
		Type: typ,
	}
}

func CreateV3ServicesDeduplicationRulesExpressionBranchRHSBoolean(boolean bool) V3ServicesDeduplicationRulesExpressionBranchRHS {
	typ := V3ServicesDeduplicationRulesExpressionBranchRHSTypeBoolean

	return V3ServicesDeduplicationRulesExpressionBranchRHS{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateV3ServicesDeduplicationRulesExpressionBranchRHSInt32(int32T int) V3ServicesDeduplicationRulesExpressionBranchRHS {
	typ := V3ServicesDeduplicationRulesExpressionBranchRHSTypeInt32

	return V3ServicesDeduplicationRulesExpressionBranchRHS{
		Int32: &int32T,
		Type:  typ,
	}
}

func CreateV3ServicesDeduplicationRulesExpressionBranchRHSFloat32(float32T float32) V3ServicesDeduplicationRulesExpressionBranchRHS {
	typ := V3ServicesDeduplicationRulesExpressionBranchRHSTypeFloat32

	return V3ServicesDeduplicationRulesExpressionBranchRHS{
		Float32: &float32T,
		Type:    typ,
	}
}

func (u *V3ServicesDeduplicationRulesExpressionBranchRHS) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = V3ServicesDeduplicationRulesExpressionBranchRHSTypeStr
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = V3ServicesDeduplicationRulesExpressionBranchRHSTypeBoolean
		return nil
	}

	var int32Var int = 0
	if err := utils.UnmarshalJSON(data, &int32Var, "", true, nil); err == nil {
		u.Int32 = &int32Var
		u.Type = V3ServicesDeduplicationRulesExpressionBranchRHSTypeInt32
		return nil
	}

	var float32Var float32 = float32(0)
	if err := utils.UnmarshalJSON(data, &float32Var, "", true, nil); err == nil {
		u.Float32 = &float32Var
		u.Type = V3ServicesDeduplicationRulesExpressionBranchRHSTypeFloat32
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for V3ServicesDeduplicationRulesExpressionBranchRHS", string(data))
}

func (u V3ServicesDeduplicationRulesExpressionBranchRHS) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Int32 != nil {
		return utils.MarshalJSON(u.Int32, "", true)
	}

	if u.Float32 != nil {
		return utils.MarshalJSON(u.Float32, "", true)
	}

	return nil, errors.New("could not marshal union type V3ServicesDeduplicationRulesExpressionBranchRHS: all fields are null")
}

type V3ServicesDeduplicationRulesExpressionBranch struct {
	LHS string                                          `json:"lhs"`
	Op  *V3ServicesDeduplicationRulesExpressionBranchOp `json:"op,omitempty"`
	RHS V3ServicesDeduplicationRulesExpressionBranchRHS `json:"rhs"`
}

func (v *V3ServicesDeduplicationRulesExpressionBranch) GetLHS() string {
	if v == nil {
		return ""
	}
	return v.LHS
}

func (v *V3ServicesDeduplicationRulesExpressionBranch) GetOp() *V3ServicesDeduplicationRulesExpressionBranchOp {
	if v == nil {
		return nil
	}
	return v.Op
}

func (v *V3ServicesDeduplicationRulesExpressionBranch) GetRHS() V3ServicesDeduplicationRulesExpressionBranchRHS {
	if v == nil {
		return V3ServicesDeduplicationRulesExpressionBranchRHS{}
	}
	return v.RHS
}
